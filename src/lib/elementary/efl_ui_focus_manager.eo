import efl_ui;
import eina_types;

struct @free(efl_ui_focus_relation_free) Efl.Ui.Focus.Relations {
    [[Structure holding the graph of relations between focussable objects.

      @since 1.20
    ]]
    right : list<Efl.Ui.Focus.Object> @owned; [[List of objects on the right side]]
    left : list<Efl.Ui.Focus.Object> @owned; [[[List of objects on the left side]]
    top : list<Efl.Ui.Focus.Object> @owned; [[[List of objects above]]
    down : list<Efl.Ui.Focus.Object> @owned; [[[List of objects below]]
    next : Efl.Ui.Focus.Object; [[[Next object]]
    prev : Efl.Ui.Focus.Object; [[Previous object]]
    parent : Efl.Ui.Focus.Object; [[Parent object]]
    redirect : Efl.Ui.Focus.Manager; [[Redirect manager]]
    node : Efl.Ui.Focus.Object; [[The node where this is the information from]]
    logical : bool; [[$true if this node is only logical]]
    position_in_history : int; [[The position in the history stack]]
}

struct Efl.Ui.Focus.Manager_Logical_End_Detail {
    [[Structure holding the focus object with extra information on logical end

      @since 1.21
    ]]
    is_regular_end : bool; [[$true if logical end, $false otherwise]]
    element : Efl.Ui.Focus.Object; [[Focus object element]]
}

interface @beta Efl.Ui.Focus.Manager {
    [[Interface for managing focus objects

      This interface is build in order to support movement of the focus property in a set of widgets.
      The movement of the focus property can happen in a tree manner, or a graph manner. The movements is also keeping track of the history of focused elements. The tree interpretation differentiates between logical and none-logical widgets, a logical widget cannot receive focus, a none-logical can.

      @since 1.20
    ]]
    methods {
        move {
            [[Move the focus into the given direction.

              This call flushes all changes.
              This means all changes between the last flush and now are computed
            ]]
            params {
                direction : Efl.Ui.Focus.Direction; [[The direction to move to]]
            }
            return : Efl.Ui.Focus.Object; [[The element which is now focused]]
        }
        request_move {
            [[Return the object next in the $direction from $child.]]
            params {
                direction : Efl.Ui.Focus.Direction; [[Direction to move focus]]
                child : Efl.Ui.Focus.Object; [[The child where to look from. Pass $null to indicate the last focused child.]]
                logical : bool; [[Weather you want to have a logical node as result or a logical. Note, at a move call no logical node will get focus, and this is passed as $false there.]]
            }
            return : Efl.Ui.Focus.Object; [[Next object to focus]]
        }
        @property manager_focus {
            [[The element which is currently focused by this manager

              For the case focus is a logical child, then the item will go to the next none logical element. If there is none, focus will stay where it is right now.
            ]]

            values {
                focus : Efl.Ui.Focus.Object @nonull; [[Focused element]]
            }
        }
        @property redirect {
            [[Add a another manager to serve the move requests.

              If this value is set, all move requests are redirected to this
              manager object. Set it to $null once nothing should be redirected
              anymore.
            ]]
            values {
                redirect : Efl.Ui.Focus.Manager; [[The redirect manager.]]
            }
        }
        @property border_elements {
            [[The list of elements which are at the border of the graph.

              This means one of the relations right,left or down,up are not set.
              This call flushes all changes. See @Efl.Ui.Focus.Manager.move
            ]]
            get {}
            values {
                border_elements : iterator<Efl.Ui.Focus.Object>; [[An iterator
                   over the border objects.]]
            }
        }
        @property viewport_elements {
            [[Get all elements that are at the border of the viewport

              Every element returned by this is located in the viewport rectangle,
              but has a right,left,down or up relation outside the viewport.
            ]]
            get {}
            keys {
                viewport : Eina.Rect;
            }
            values {
              viewport_elements : iterator<Efl.Ui.Focus.Object>;
            }
        }
        @property root {
            [[Root node for all logical subtrees.

              This property can only be set once.
            ]]
            set {
                return : bool; [[If $true, this is the root node]]
            }

            get {

            }

            values {
                root : Efl.Ui.Focus.Object @nonull; [[Will be registered into
                    this manager object.]]
            }
        }
        request_subchild {
            [[Return the widget in the direction next.

              The returned widget is a child of $root.
              Its garanteed that child will not be prepared once again,
              so you can call this function out of a prepare call.
            ]]
              params {
                 root : Efl.Ui.Focus.Object; [[Parent for returned child]]
              }
              return : Efl.Ui.Focus.Object; [[Child of passed parameter]]
        }
        fetch {
            [[This will fetch the data from a registered node.

              Be aware this function will trigger all dirty nodes to be computed
            ]]
            params {
                child : Efl.Ui.Focus.Object; [[The child object to inspect.]]
            }
            return : ptr(Efl.Ui.Focus.Relations) @owned; [[The list of relations
                starting from $child.]]
        }
        logical_end {
            [[Return the last logical object.

              The returned object is the last object that would be returned if you start at the root and move the direction into next.
            ]]
            return : Efl.Ui.Focus.Manager_Logical_End_Detail; [[Last object]]
        }
        reset_history {
            [[Reset the history stack of this manager object.
              This means the most upper element will be unfocused, all other elements will be removed from the remembered before.

              To not break the assertion that there should be always a focused element, you should focus a other element immidiatly after calling this.
            ]]
        }
        pop_history_stack {
            [[Remove the most upper history element, and focus the next possible element

              If there is a element that was focused before, it will be taken. Otherwise, the best fitting element from the registered elements will be focused.
            ]]
        }
        setup_on_first_touch {
           [[Called when this manager is set as redirect.

             In case that this is called as an result of a move call, $direction and $entry will be set to the direction of the move call, and the entry object will be set to the object, that had this object as redirect property.
           ]]
           params {
             direction : Efl.Ui.Focus.Direction; [[The direction in which this should be setup]]
             entry : Efl.Ui.Focus.Object; [[The object that caused this manager to be redirect]]
           }
        }
        dirty_logic_freeze {
          [[This disables the cache invalidation when a object is moved.

            Even the object is moved, the focus manager will not recalculate its relations, this can be used when you know that the set of widgets in the focus manager is equally moved. so the relations between the widets in the set do not change.
          ]]
        }
        dirty_logic_unfreeze {
          [[This enables the cache invalidation when a object is moved.

            This is the counter part to @.dirty_logic_freeze
          ]]
        }
    }
    events {
        redirect,changed : Efl.Ui.Focus.Manager; [[Redirect object has changed, the old manager is passed as event info]]
        flush,pre: void; [[Next to this event, the manager object will calculate relations in the graph. Can be used to add / remove children in a lazy manner]]
        coords,dirty: void; [[Cached calculation results have been invalidated]]
        manager_focus,changed : Efl.Ui.Focus.Object; [[the manager_focus property has changed, the previous focused object is passed as event argument]]
        dirty_logic_freeze,changed : bool; [[Called when this focus manager is frozen or unfrozen, even_info beeing $true indicates that it is now frozen, $false indicates that it is unfrozen.]]
    }
}
